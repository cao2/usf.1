package platu.logicAnalysis;

import java.util.ArrayList;
import java.util.List;
import platu.main.Options;
import platu.main.Options.SearchTypeDef;
import platu.stategraph.StateGraph;

public class CompositionalThread extends Thread{
	// List of state graphs that modify inputs to the state graph of this thread
	private List<StateGraph> srcList = null;
	
	// State graph this thread to which this thread belongs
	private StateGraph sg = null;
	
	// Number of new transitions generated by this thread
	private int newTransitions = 0;
	
	
	/**
	 * Constructor.
	 * @param sg - State graph
	 * @param srcList - List of state graphs that are the source of inputs.
	 * @param iter - CRA iteration
	 */
	public CompositionalThread(StateGraph sg, List<StateGraph> srcList){
		this.srcList = srcList;
		this.sg = sg;
	}
	
	/**
	 * Returns the number of new state transitions generated when this thread was run.
	 * @return Number of new state transitions
	 */
	public int getNewTransitions(){
		return this.newTransitions;
	}
	
	/**
	 * Returns the state graph to which this thread belongs.
	 * @return State graph
	 */
	public StateGraph getStateGraph(){
		return this.sg;
	}
	
	/*
	 * (non-Javadoc)
	 * @see java.lang.Thread#run()
	 * This function is called when the thread is started.
	 */
	public void run(){
		List<Constraint> newConstraintSet = new ArrayList<Constraint>();
		List<Constraint> oldConstraintSet = new ArrayList<Constraint>();
		
		for(StateGraph srcSG : this.srcList){
			if(Options.getSearchType() == SearchTypeDef.CRA){
				CompositionalAnalysis.extractConstraints(this.sg, srcSG, newConstraintSet, oldConstraintSet);
				this.newTransitions += CompositionalAnalysis.applyConstraintSet(this.sg, srcSG, newConstraintSet, oldConstraintSet);
			}
			else{
				CompositionalAnalysis.extractConstraintsOrig(this.sg, srcSG, oldConstraintSet);
				this.newTransitions += CompositionalAnalysis.applyConstraintSetOrig(this.sg, srcSG, oldConstraintSet);
			}
		}
	}	
}
